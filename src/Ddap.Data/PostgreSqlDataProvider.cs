using System.Data;
using Dapper;
using Ddap.Core;
using Npgsql;

namespace Ddap.Data;

/// <summary>
/// Data provider implementation for PostgreSQL database.
/// </summary>
internal class PostgreSqlDataProvider : IDataProvider
{
    private readonly DdapOptions _options;

    /// <summary>
    /// Initializes a new instance of the <see cref="PostgreSqlDataProvider"/> class.
    /// </summary>
    /// <param name="options">The DDAP configuration options.</param>
    public PostgreSqlDataProvider(DdapOptions options)
    {
        _options = options;
    }

    /// <inheritdoc/>
    public string ProviderName => "PostgreSQL";

    /// <inheritdoc/>
    public async Task<IReadOnlyList<IEntityConfiguration>> LoadEntitiesAsync(
        CancellationToken cancellationToken = default
    )
    {
        using var connection = new NpgsqlConnection(_options.ConnectionString);
        await connection.OpenAsync(cancellationToken);

        var tables = await LoadTablesAsync(connection);
        var entities = new List<IEntityConfiguration>();

        foreach (var (schema, tableName) in tables)
        {
            var properties = await LoadPropertiesAsync(connection, schema, tableName);
            var indexes = await LoadIndexesAsync(connection, schema, tableName);

            entities.Add(
                new EntityConfiguration
                {
                    EntityName = tableName,
                    SchemaName = schema,
                    Properties = properties,
                    Indexes = indexes,
                    Relationships = Array.Empty<IRelationshipConfiguration>(), // Simplified for now
                }
            );
        }

        return entities;
    }

    private async Task<List<(string Schema, string TableName)>> LoadTablesAsync(
        IDbConnection connection
    )
    {
        var query =
            @"
            SELECT 
                table_schema as Schema,
                table_name as TableName
            FROM information_schema.tables
            WHERE table_type = 'BASE TABLE' AND table_schema NOT IN ('pg_catalog', 'information_schema')";

        if (_options.IncludeSchemas?.Count > 0)
        {
            query += $" AND table_schema IN ('{string.Join("','", _options.IncludeSchemas)}')";
        }

        if (_options.ExcludeSchemas?.Count > 0)
        {
            query += $" AND table_schema NOT IN ('{string.Join("','", _options.ExcludeSchemas)}')";
        }

        var result = await connection.QueryAsync<(string, string)>(query);
        return result.ToList();
    }

    private async Task<IReadOnlyList<IPropertyConfiguration>> LoadPropertiesAsync(
        IDbConnection connection,
        string schema,
        string tableName
    )
    {
        var query =
            @"
            SELECT 
                c.column_name as ColumnName,
                c.data_type as DataType,
                c.is_nullable as IsNullable,
                c.character_maximum_length as MaxLength,
                CASE WHEN c.column_default LIKE 'nextval%' THEN true ELSE false END as IsIdentity,
                CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END as IsPrimaryKey
            FROM information_schema.columns c
            LEFT JOIN (
                SELECT ku.table_schema, ku.table_name, ku.column_name
                FROM information_schema.table_constraints tc
                JOIN information_schema.key_column_usage ku
                    ON tc.constraint_type = 'PRIMARY KEY' 
                    AND tc.constraint_name = ku.constraint_name
                    AND tc.table_schema = ku.table_schema
                    AND tc.table_name = ku.table_name
            ) pk ON c.table_schema = pk.table_schema 
                AND c.table_name = pk.table_name 
                AND c.column_name = pk.column_name
            WHERE c.table_schema = @Schema AND c.table_name = @TableName
            ORDER BY c.ordinal_position";

        var columns = await connection.QueryAsync(
            query,
            new { Schema = schema, TableName = tableName }
        );

        return columns
            .Select(col =>
                new PropertyConfiguration
                {
                    PropertyName = col.ColumnName,
                    ColumnName = col.ColumnName,
                    PropertyType = MapPgTypeToClrType(col.DataType, col.IsNullable == "YES"),
                    DatabaseType = col.DataType,
                    IsPrimaryKey = col.IsPrimaryKey,
                    IsNullable = col.IsNullable == "YES",
                    IsAutoGenerated = col.IsIdentity,
                    MaxLength = col.MaxLength,
                } as IPropertyConfiguration
            )
            .ToList();
    }

    private async Task<IReadOnlyList<IIndexConfiguration>> LoadIndexesAsync(
        IDbConnection connection,
        string schema,
        string tableName
    )
    {
        var query =
            @"
            SELECT 
                i.relname as IndexName,
                ix.indisunique as IsUnique,
                array_to_string(array_agg(a.attname ORDER BY a.attnum), ',') as Columns
            FROM pg_class t
            JOIN pg_index ix ON t.oid = ix.indrelid
            JOIN pg_class i ON i.oid = ix.indexrelid
            JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)
            JOIN pg_namespace n ON n.oid = t.relnamespace
            WHERE n.nspname = @Schema AND t.relname = @TableName AND NOT ix.indisprimary
            GROUP BY i.relname, ix.indisunique";

        var indexes = await connection.QueryAsync(
            query,
            new { Schema = schema, TableName = tableName }
        );

        return indexes
            .Select(idx =>
                new IndexConfiguration
                {
                    IndexName = idx.IndexName,
                    PropertyNames = ((string)idx.Columns).Split(',').ToList(),
                    IsUnique = idx.IsUnique,
                    IsClustered = false,
                } as IIndexConfiguration
            )
            .ToList();
    }

    private static Type MapPgTypeToClrType(string sqlType, bool isNullable)
    {
        var baseType = sqlType.ToLower() switch
        {
            "integer" or "int" or "int4" => typeof(int),
            "bigint" or "int8" => typeof(long),
            "smallint" or "int2" => typeof(short),
            "boolean" or "bool" => typeof(bool),
            "numeric" or "decimal" or "money" => typeof(decimal),
            "double precision" or "float8" => typeof(double),
            "real" or "float4" => typeof(float),
            "timestamp" or "timestamp without time zone" => typeof(DateTime),
            "timestamp with time zone" or "timestamptz" => typeof(DateTimeOffset),
            "date" => typeof(DateTime),
            "time" or "time without time zone" => typeof(TimeSpan),
            "uuid" => typeof(Guid),
            "bytea" => typeof(byte[]),
            _ => typeof(string),
        };

        if (isNullable && baseType.IsValueType)
        {
            return typeof(Nullable<>).MakeGenericType(baseType);
        }

        return baseType;
    }
}
