using System.Data;
using Dapper;
using Ddap.Core;
using Microsoft.Data.SqlClient;

namespace Ddap.Data;

/// <summary>
/// Data provider implementation for Microsoft SQL Server.
/// </summary>
internal class SqlServerDataProvider : IDataProvider
{
    private readonly DdapOptions _options;

    /// <summary>
    /// Initializes a new instance of the <see cref="SqlServerDataProvider"/> class.
    /// </summary>
    /// <param name="options">The DDAP configuration options.</param>
    public SqlServerDataProvider(DdapOptions options)
    {
        _options = options;
    }

    /// <inheritdoc/>
    public string ProviderName => "SQLServer";

    /// <inheritdoc/>
    public async Task<IReadOnlyList<IEntityConfiguration>> LoadEntitiesAsync(
        CancellationToken cancellationToken = default
    )
    {
        using var connection = new SqlConnection(_options.ConnectionString);
        await connection.OpenAsync(cancellationToken);

        var tables = await LoadTablesAsync(connection);
        var entities = new List<IEntityConfiguration>();

        foreach (var (schema, tableName) in tables)
        {
            var properties = await LoadPropertiesAsync(connection, schema, tableName);
            var indexes = await LoadIndexesAsync(connection, schema, tableName);
            var relationships = await LoadRelationshipsAsync(connection, schema, tableName);

            entities.Add(
                new EntityConfiguration
                {
                    EntityName = tableName,
                    SchemaName = schema,
                    Properties = properties,
                    Indexes = indexes,
                    Relationships = relationships,
                }
            );
        }

        return entities;
    }

    private async Task<List<(string Schema, string TableName)>> LoadTablesAsync(
        IDbConnection connection
    )
    {
        var query =
            @"
            SELECT 
                TABLE_SCHEMA as Schema,
                TABLE_NAME as TableName
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_TYPE = 'BASE TABLE'";

        if (_options.IncludeSchemas?.Count > 0)
        {
            query += $" AND TABLE_SCHEMA IN ('{string.Join("','", _options.IncludeSchemas)}')";
        }

        if (_options.ExcludeSchemas?.Count > 0)
        {
            query += $" AND TABLE_SCHEMA NOT IN ('{string.Join("','", _options.ExcludeSchemas)}')";
        }

        var result = await connection.QueryAsync<(string, string)>(query);
        return result.ToList();
    }

    private async Task<IReadOnlyList<IPropertyConfiguration>> LoadPropertiesAsync(
        IDbConnection connection,
        string schema,
        string tableName
    )
    {
        var query =
            @"
            SELECT 
                c.COLUMN_NAME as ColumnName,
                c.DATA_TYPE as DataType,
                c.IS_NULLABLE as IsNullable,
                c.CHARACTER_MAXIMUM_LENGTH as MaxLength,
                COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA + '.' + c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as IsIdentity,
                CASE WHEN pk.COLUMN_NAME IS NOT NULL THEN 1 ELSE 0 END as IsPrimaryKey
            FROM INFORMATION_SCHEMA.COLUMNS c
            LEFT JOIN (
                SELECT ku.TABLE_SCHEMA, ku.TABLE_NAME, ku.COLUMN_NAME
                FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
                JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE ku
                    ON tc.CONSTRAINT_TYPE = 'PRIMARY KEY' 
                    AND tc.CONSTRAINT_NAME = ku.CONSTRAINT_NAME
            ) pk ON c.TABLE_SCHEMA = pk.TABLE_SCHEMA 
                AND c.TABLE_NAME = pk.TABLE_NAME 
                AND c.COLUMN_NAME = pk.COLUMN_NAME
            WHERE c.TABLE_SCHEMA = @Schema AND c.TABLE_NAME = @TableName
            ORDER BY c.ORDINAL_POSITION";

        var columns = await connection.QueryAsync(
            query,
            new { Schema = schema, TableName = tableName }
        );

        return columns
            .Select(col =>
                new PropertyConfiguration
                {
                    PropertyName = col.ColumnName,
                    ColumnName = col.ColumnName,
                    PropertyType = MapSqlTypeToClrType(col.DataType, col.IsNullable == "YES"),
                    DatabaseType = col.DataType,
                    IsPrimaryKey = col.IsPrimaryKey == 1,
                    IsNullable = col.IsNullable == "YES",
                    IsAutoGenerated = col.IsIdentity == 1,
                    MaxLength = col.MaxLength,
                } as IPropertyConfiguration
            )
            .ToList();
    }

    private async Task<IReadOnlyList<IIndexConfiguration>> LoadIndexesAsync(
        IDbConnection connection,
        string schema,
        string tableName
    )
    {
        var query =
            @"
            SELECT 
                i.name as IndexName,
                i.is_unique as IsUnique,
                i.type_desc as TypeDesc,
                STRING_AGG(c.name, ',') WITHIN GROUP (ORDER BY ic.key_ordinal) as Columns
            FROM sys.indexes i
            INNER JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id
            INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
            INNER JOIN sys.tables t ON i.object_id = t.object_id
            INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
            WHERE s.name = @Schema AND t.name = @TableName AND i.is_primary_key = 0
            GROUP BY i.name, i.is_unique, i.type_desc";

        var indexes = await connection.QueryAsync(
            query,
            new { Schema = schema, TableName = tableName }
        );

        return indexes
            .Select(idx =>
                new IndexConfiguration
                {
                    IndexName = idx.IndexName,
                    PropertyNames = ((string)idx.Columns).Split(',').ToList(),
                    IsUnique = idx.IsUnique,
                    IsClustered = idx.TypeDesc == "CLUSTERED",
                } as IIndexConfiguration
            )
            .ToList();
    }

    private async Task<IReadOnlyList<IRelationshipConfiguration>> LoadRelationshipsAsync(
        IDbConnection connection,
        string schema,
        string tableName
    )
    {
        var query =
            @"
            SELECT 
                fk.name as ForeignKeyName,
                OBJECT_SCHEMA_NAME(fk.referenced_object_id) as ReferencedSchema,
                OBJECT_NAME(fk.referenced_object_id) as ReferencedTable,
                STRING_AGG(c.name, ',') WITHIN GROUP (ORDER BY fkc.constraint_column_id) as ForeignKeyColumns,
                STRING_AGG(rc.name, ',') WITHIN GROUP (ORDER BY fkc.constraint_column_id) as ReferencedColumns
            FROM sys.foreign_keys fk
            INNER JOIN sys.foreign_key_columns fkc ON fk.object_id = fkc.constraint_object_id
            INNER JOIN sys.columns c ON fkc.parent_object_id = c.object_id AND fkc.parent_column_id = c.column_id
            INNER JOIN sys.columns rc ON fkc.referenced_object_id = rc.object_id AND fkc.referenced_column_id = rc.column_id
            INNER JOIN sys.tables t ON fk.parent_object_id = t.object_id
            INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
            WHERE s.name = @Schema AND t.name = @TableName
            GROUP BY fk.name, fk.referenced_object_id";

        var relationships = await connection.QueryAsync(
            query,
            new { Schema = schema, TableName = tableName }
        );

        return relationships
            .Select(rel =>
                new RelationshipConfiguration
                {
                    RelationshipName = rel.ForeignKeyName,
                    RelatedEntityName = rel.ReferencedTable,
                    RelationshipType = RelationshipType.OneToMany,
                    ForeignKeyProperties = ((string)rel.ForeignKeyColumns).Split(',').ToList(),
                    PrincipalKeyProperties = ((string)rel.ReferencedColumns).Split(',').ToList(),
                    IsRequired = false, // Can be enhanced to detect required relationships
                } as IRelationshipConfiguration
            )
            .ToList();
    }

    private static Type MapSqlTypeToClrType(string sqlType, bool isNullable)
    {
        var baseType = sqlType.ToLower() switch
        {
            "int" => typeof(int),
            "bigint" => typeof(long),
            "smallint" => typeof(short),
            "tinyint" => typeof(byte),
            "bit" => typeof(bool),
            "decimal" or "numeric" or "money" or "smallmoney" => typeof(decimal),
            "float" => typeof(double),
            "real" => typeof(float),
            "datetime" or "datetime2" or "smalldatetime" or "date" => typeof(DateTime),
            "time" => typeof(TimeSpan),
            "datetimeoffset" => typeof(DateTimeOffset),
            "uniqueidentifier" => typeof(Guid),
            "binary" or "varbinary" or "image" => typeof(byte[]),
            _ => typeof(string),
        };

        if (isNullable && baseType.IsValueType)
        {
            return typeof(Nullable<>).MakeGenericType(baseType);
        }

        return baseType;
    }
}
