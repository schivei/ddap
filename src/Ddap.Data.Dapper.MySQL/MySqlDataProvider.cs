using System.Data;
using Dapper;
using Ddap.Core;
using Ddap.Core.Internals;
using MySqlConnector;

namespace Ddap.Data.Dapper.MySQL;

/// <summary>
/// Data provider implementation for MySQL database using Dapper.
/// </summary>
public class MySqlDataProvider : IDataProvider
{
    private readonly DdapOptions _options;

    /// <summary>
    /// Initializes a new instance of the <see cref="MySqlDataProvider"/> class.
    /// </summary>
    /// <param name="options">The DDAP configuration options.</param>
    public MySqlDataProvider(DdapOptions options)
    {
        _options = options;
    }

    /// <inheritdoc/>
    public string ProviderName => "MySQL";

    /// <inheritdoc/>
    public async Task<IReadOnlyList<IEntityConfiguration>> LoadEntitiesAsync(
        CancellationToken cancellationToken = default
    )
    {
        using var connection = new MySqlConnection(_options.ConnectionString);
        await connection.OpenAsync(cancellationToken);

        var database = connection.Database;
        var tables = await LoadTablesAsync(connection, database);
        var entities = new List<IEntityConfiguration>();

        foreach (var (schema, tableName) in tables)
        {
            var properties = await LoadPropertiesAsync(connection, database, tableName);
            var indexes = await LoadIndexesAsync(connection, database, tableName);

            entities.Add(
                new EntityConfiguration
                {
                    EntityName = tableName,
                    SchemaName = schema,
                    Properties = properties,
                    Indexes = indexes,
                    Relationships = Array.Empty<IRelationshipConfiguration>() // Simplified for now
                }
            );
        }

        return entities;
    }

    private async Task<List<(string Schema, string TableName)>> LoadTablesAsync(
        IDbConnection connection,
        string database
    )
    {
        var query = @"
            SELECT 
                TABLE_SCHEMA as Schema,
                TABLE_NAME as TableName
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_SCHEMA = @Database AND TABLE_TYPE = 'BASE TABLE'";

        var result = await connection.QueryAsync<(string, string)>(query, new { Database = database });
        return result.ToList();
    }

    private async Task<IReadOnlyList<IPropertyConfiguration>> LoadPropertiesAsync(
        IDbConnection connection,
        string database,
        string tableName
    )
    {
        var query = @"
            SELECT 
                COLUMN_NAME as ColumnName,
                DATA_TYPE as DataType,
                IS_NULLABLE as IsNullable,
                CHARACTER_MAXIMUM_LENGTH as MaxLength,
                EXTRA as Extra,
                COLUMN_KEY as ColumnKey
            FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_SCHEMA = @Database AND TABLE_NAME = @TableName
            ORDER BY ORDINAL_POSITION";

        var columns = await connection.QueryAsync(
            query,
            new { Database = database, TableName = tableName }
        );

        return columns
            .Select(
                col =>
                    new PropertyConfiguration
                    {
                        PropertyName = col.ColumnName,
                        ColumnName = col.ColumnName,
                        PropertyType = MapMySqlTypeToClrType(col.DataType, col.IsNullable == "YES"),
                        DatabaseType = col.DataType,
                        IsPrimaryKey = col.ColumnKey == "PRI",
                        IsNullable = col.IsNullable == "YES",
                        IsAutoGenerated = ((string)col.Extra).Contains("auto_increment"),
                        MaxLength = col.MaxLength
                    } as IPropertyConfiguration
            )
            .ToList();
    }

    private async Task<IReadOnlyList<IIndexConfiguration>> LoadIndexesAsync(
        IDbConnection connection,
        string database,
        string tableName
    )
    {
        var query = @"
            SELECT 
                INDEX_NAME as IndexName,
                NON_UNIQUE as NonUnique,
                GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as Columns
            FROM INFORMATION_SCHEMA.STATISTICS
            WHERE TABLE_SCHEMA = @Database AND TABLE_NAME = @TableName AND INDEX_NAME != 'PRIMARY'
            GROUP BY INDEX_NAME, NON_UNIQUE";

        var indexes = await connection.QueryAsync(
            query,
            new { Database = database, TableName = tableName }
        );

        return indexes
            .Select(
                idx =>
                    new IndexConfiguration
                    {
                        IndexName = idx.IndexName,
                        PropertyNames = ((string)idx.Columns).Split(',').ToList(),
                        IsUnique = idx.NonUnique == 0,
                        IsClustered = false
                    } as IIndexConfiguration
            )
            .ToList();
    }

    private static Type MapMySqlTypeToClrType(string sqlType, bool isNullable)
    {
        var baseType = sqlType.ToLower() switch
        {
            "int" or "integer" => typeof(int),
            "bigint" => typeof(long),
            "smallint" => typeof(short),
            "tinyint" => typeof(byte),
            "bit" => typeof(bool),
            "decimal" or "numeric" => typeof(decimal),
            "double" or "float" => typeof(double),
            "datetime" or "timestamp" => typeof(DateTime),
            "date" => typeof(DateTime),
            "time" => typeof(TimeSpan),
            "char" or "varchar" or "text" or "longtext" or "mediumtext" or "tinytext" => typeof(
                string
            ),
            "binary" or "varbinary" or "blob" or "longblob" or "mediumblob" or "tinyblob" => typeof(
                byte[]
            ),
            "guid" => typeof(Guid),
            _ => typeof(string)
        };

        if (isNullable && baseType.IsValueType)
        {
            return typeof(Nullable<>).MakeGenericType(baseType);
        }

        return baseType;
    }
}
